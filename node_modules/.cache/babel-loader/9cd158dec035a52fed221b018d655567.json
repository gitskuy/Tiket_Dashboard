{"remainingRequest":"/home/ahmad/tiket/experiments/myproject/node_modules/babel-loader/lib/index.js!/home/ahmad/tiket/experiments/myproject/src/vuestic-theme/vuestic-components/vuestic-popup/quasar/utils/popup.js","dependencies":[{"path":"/home/ahmad/tiket/experiments/myproject/src/vuestic-theme/vuestic-components/vuestic-popup/quasar/utils/popup.js","mtime":1563286052653},{"path":"/home/ahmad/tiket/experiments/myproject/node_modules/cache-loader/dist/cjs.js","mtime":1563287225222},{"path":"/home/ahmad/tiket/experiments/myproject/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.regexp.split\";\nimport { position as eventPosition } from './event.js';\nimport { getScrollbarWidth } from './scroll.js';\nexport function getAnchorPosition(el, offset) {\n  var top, left, right, bottom, a;\n\n  var _el$getBoundingClient = el.getBoundingClientRect();\n\n  top = _el$getBoundingClient.top;\n  left = _el$getBoundingClient.left;\n  right = _el$getBoundingClient.right;\n  bottom = _el$getBoundingClient.bottom;\n  a = {\n    top: top,\n    left: left,\n    width: el.offsetWidth,\n    height: el.offsetHeight\n  };\n\n  if (offset) {\n    a.top -= offset[1];\n    a.left -= offset[0];\n\n    if (bottom) {\n      bottom += offset[1];\n    }\n\n    if (right) {\n      right += offset[0];\n    }\n\n    a.width += offset[0];\n    a.height += offset[1];\n  }\n\n  a.right = right || a.left + a.width;\n  a.bottom = bottom || a.top + a.height;\n  a.middle = a.left + (a.right - a.left) / 2;\n  a.center = a.top + (a.bottom - a.top) / 2;\n  return a;\n}\nexport function getTargetPosition(el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth\n  };\n}\nexport function repositionIfNeeded(anchor, target, selfOrigin, anchorOrigin, targetPosition, cover) {\n  var margin = getScrollbarWidth();\n  var _window = window,\n      innerHeight = _window.innerHeight,\n      innerWidth = _window.innerWidth; // don't go bellow scrollbars\n\n  innerHeight -= margin;\n  innerWidth -= margin;\n\n  if (targetPosition.top < 0 || targetPosition.top + target.bottom > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      targetPosition.top = anchor[selfOrigin.vertical] > innerHeight / 2 ? innerHeight - target.bottom : 0;\n      targetPosition.maxHeight = Math.min(target.bottom, innerHeight);\n    } else if (anchor[selfOrigin.vertical] > innerHeight / 2) {\n      var anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchor.center : anchorOrigin.vertical === selfOrigin.vertical ? anchor.bottom : anchor.top);\n      targetPosition.maxHeight = Math.min(target.bottom, anchorY);\n      targetPosition.top = Math.max(0, anchorY - targetPosition.maxHeight);\n    } else {\n      targetPosition.top = anchorOrigin.vertical === 'center' ? anchor.center : anchorOrigin.vertical === selfOrigin.vertical ? anchor.top : anchor.bottom;\n      targetPosition.maxHeight = Math.min(target.bottom, innerHeight - targetPosition.top);\n    }\n  }\n\n  if (targetPosition.left < 0 || targetPosition.left + target.right > innerWidth) {\n    targetPosition.maxWidth = Math.min(target.right, innerWidth);\n\n    if (selfOrigin.horizontal === 'middle') {\n      targetPosition.left = anchor[selfOrigin.horizontal] > innerWidth / 2 ? innerWidth - target.right : 0;\n    } else if (cover) {\n      targetPosition.left = targetPosition.left < 0 ? 0 : innerWidth - target.right;\n    } else if (anchor[selfOrigin.horizontal] > innerWidth / 2) {\n      var _anchorY = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchor.center : anchorOrigin.horizontal === selfOrigin.horizontal ? anchor.right : anchor.left);\n\n      targetPosition.maxWidth = Math.min(target.right, _anchorY);\n      targetPosition.left = Math.max(0, _anchorY - targetPosition.maxWidth);\n    } else {\n      targetPosition.left = anchorOrigin.horizontal === 'middle' ? anchor.center : anchorOrigin.horizontal === selfOrigin.horizontal ? anchor.left : anchor.right;\n      targetPosition.maxWidth = Math.min(target.right, innerWidth - targetPosition.left);\n    }\n  }\n\n  return targetPosition;\n}\nexport function parseHorizTransformOrigin(pos) {\n  return pos === 'middle' ? 'center' : pos;\n}\nexport function setPosition(_ref) {\n  var el = _ref.el,\n      animate = _ref.animate,\n      anchorEl = _ref.anchorEl,\n      anchorOrigin = _ref.anchorOrigin,\n      selfOrigin = _ref.selfOrigin,\n      maxHeight = _ref.maxHeight,\n      event = _ref.event,\n      anchorClick = _ref.anchorClick,\n      touchPosition = _ref.touchPosition,\n      offset = _ref.offset,\n      touchOffset = _ref.touchOffset,\n      cover = _ref.cover;\n  var anchor;\n  el.style.maxHeight = maxHeight || '65vh';\n  el.style.maxWidth = '100vw';\n\n  if (event && (!anchorClick || touchPosition)) {\n    var _eventPosition = eventPosition(event),\n        top = _eventPosition.top,\n        left = _eventPosition.left;\n\n    anchor = {\n      top: top,\n      left: left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      center: top,\n      middle: left,\n      bottom: top + 1\n    };\n  } else {\n    if (touchOffset) {\n      var _anchorEl$getBounding = anchorEl.getBoundingClientRect(),\n          anchorTop = _anchorEl$getBounding.top,\n          anchorLeft = _anchorEl$getBounding.left;\n\n      var _top = anchorTop + touchOffset.top;\n\n      var _left = anchorLeft + touchOffset.left;\n\n      anchor = {\n        top: _top,\n        left: _left,\n        width: 1,\n        height: 1,\n        right: _left + 1,\n        center: _top,\n        middle: _left,\n        bottom: _top + 1\n      };\n    } else {\n      anchor = getAnchorPosition(anchorEl, offset);\n    }\n  }\n\n  var target = getTargetPosition(el);\n  var targetPosition = {\n    top: anchor[anchorOrigin.vertical] - target[selfOrigin.vertical],\n    left: anchor[anchorOrigin.horizontal] - target[selfOrigin.horizontal]\n  };\n  targetPosition = repositionIfNeeded(anchor, target, selfOrigin, anchorOrigin, targetPosition, cover);\n  el.style.top = Math.max(0, targetPosition.top) + 'px';\n  el.style.left = Math.max(0, targetPosition.left) + 'px';\n\n  if (targetPosition.maxHeight) {\n    el.style.maxHeight = \"\".concat(targetPosition.maxHeight, \"px\");\n  }\n\n  if (targetPosition.maxWidth) {\n    el.style.maxWidth = \"\".concat(targetPosition.maxWidth, \"px\");\n  }\n\n  if (animate) {\n    var directions = targetPosition.top < anchor.top ? ['up', 'down'] : ['down', 'up'];\n    el.classList.add(\"animate-popup-\".concat(directions[0]));\n    el.classList.remove(\"animate-popup-\".concat(directions[1]));\n  }\n}\nexport function positionValidator(pos) {\n  var parts = pos.split(' ');\n\n  if (parts.length !== 2) {\n    return false;\n  }\n\n  if (!['top', 'center', 'bottom'].includes(parts[0])) {\n    // eslint-disable-next-line no-console\n    console.error('Anchor/Self position must start with one of top/center/bottom');\n    return false;\n  }\n\n  if (!['left', 'middle', 'right'].includes(parts[1])) {\n    // eslint-disable-next-line no-console\n    console.error('Anchor/Self position must end with one of left/middle/right');\n    return false;\n  }\n\n  return true;\n}\nexport function offsetValidator(val) {\n  if (!val) {\n    return true;\n  }\n\n  if (val.length !== 2) {\n    return false;\n  }\n\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false;\n  }\n\n  return true;\n}\nexport function parsePosition(pos) {\n  var parts = pos.split(' ');\n  return {\n    vertical: parts[0],\n    horizontal: parts[1]\n  };\n}",{"version":3,"sources":["/home/ahmad/tiket/experiments/myproject/src/vuestic-theme/vuestic-components/vuestic-popup/quasar/utils/popup.js"],"names":["position","eventPosition","getScrollbarWidth","getAnchorPosition","el","offset","top","left","right","bottom","a","getBoundingClientRect","width","offsetWidth","height","offsetHeight","middle","center","getTargetPosition","repositionIfNeeded","anchor","target","selfOrigin","anchorOrigin","targetPosition","cover","margin","window","innerHeight","innerWidth","vertical","maxHeight","Math","min","anchorY","max","maxWidth","horizontal","parseHorizTransformOrigin","pos","setPosition","animate","anchorEl","event","anchorClick","touchPosition","touchOffset","style","anchorTop","anchorLeft","directions","classList","add","remove","positionValidator","parts","split","length","includes","console","error","offsetValidator","val","parsePosition"],"mappings":"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","sourcesContent":["import { position as eventPosition } from './event.js'\nimport { getScrollbarWidth } from './scroll.js'\n\nexport function getAnchorPosition (el, offset) {\n  let top, left, right, bottom, a\n  ({ top, left, right, bottom } = el.getBoundingClientRect())\n  a = {\n    top,\n    left,\n    width: el.offsetWidth,\n    height: el.offsetHeight,\n  }\n\n  if (offset) {\n    a.top -= offset[1]\n    a.left -= offset[0]\n    if (bottom) {\n      bottom += offset[1]\n    }\n    if (right) {\n      right += offset[0]\n    }\n    a.width += offset[0]\n    a.height += offset[1]\n  }\n\n  a.right = right || a.left + a.width\n  a.bottom = bottom || a.top + a.height\n  a.middle = a.left + ((a.right - a.left) / 2)\n  a.center = a.top + ((a.bottom - a.top) / 2)\n\n  return a\n}\n\nexport function getTargetPosition (el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth,\n  }\n}\n\nexport function repositionIfNeeded (anchor, target, selfOrigin, anchorOrigin, targetPosition, cover) {\n  const margin = getScrollbarWidth()\n  let { innerHeight, innerWidth } = window\n  // don't go bellow scrollbars\n  innerHeight -= margin\n  innerWidth -= margin\n\n  if (targetPosition.top < 0 || targetPosition.top + target.bottom > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      targetPosition.top = anchor[selfOrigin.vertical] > innerHeight / 2 ? innerHeight - target.bottom : 0\n      targetPosition.maxHeight = Math.min(target.bottom, innerHeight)\n    } else if (anchor[selfOrigin.vertical] > innerHeight / 2) {\n      const anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchor.center : (anchorOrigin.vertical === selfOrigin.vertical ? anchor.bottom : anchor.top))\n      targetPosition.maxHeight = Math.min(target.bottom, anchorY)\n      targetPosition.top = Math.max(0, anchorY - targetPosition.maxHeight)\n    } else {\n      targetPosition.top = anchorOrigin.vertical === 'center' ? anchor.center : (anchorOrigin.vertical === selfOrigin.vertical ? anchor.top : anchor.bottom)\n      targetPosition.maxHeight = Math.min(target.bottom, innerHeight - targetPosition.top)\n    }\n  }\n\n  if (targetPosition.left < 0 || targetPosition.left + target.right > innerWidth) {\n    targetPosition.maxWidth = Math.min(target.right, innerWidth)\n    if (selfOrigin.horizontal === 'middle') {\n      targetPosition.left = anchor[selfOrigin.horizontal] > innerWidth / 2 ? innerWidth - target.right : 0\n    } else if (cover) {\n      targetPosition.left = targetPosition.left < 0 ? 0 : innerWidth - target.right\n    } else if (anchor[selfOrigin.horizontal] > innerWidth / 2) {\n      const anchorY = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchor.center : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchor.right : anchor.left))\n      targetPosition.maxWidth = Math.min(target.right, anchorY)\n      targetPosition.left = Math.max(0, anchorY - targetPosition.maxWidth)\n    } else {\n      targetPosition.left = anchorOrigin.horizontal === 'middle' ? anchor.center : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchor.left : anchor.right)\n      targetPosition.maxWidth = Math.min(target.right, innerWidth - targetPosition.left)\n    }\n  }\n\n  return targetPosition\n}\n\nexport function parseHorizTransformOrigin (pos) {\n  return pos === 'middle' ? 'center' : pos\n}\n\nexport function setPosition ({ el, animate, anchorEl, anchorOrigin, selfOrigin, maxHeight, event, anchorClick, touchPosition, offset, touchOffset, cover }) {\n  let anchor\n  el.style.maxHeight = maxHeight || '65vh'\n  el.style.maxWidth = '100vw'\n\n  if (event && (!anchorClick || touchPosition)) {\n    const { top, left } = eventPosition(event)\n    anchor = {\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      center: top,\n      middle: left,\n      bottom: top + 1,\n    }\n  } else {\n    if (touchOffset) {\n      const { top: anchorTop, left: anchorLeft } = anchorEl.getBoundingClientRect()\n      const top = anchorTop + touchOffset.top\n      const left = anchorLeft + touchOffset.left\n      anchor = {\n        top,\n        left,\n        width: 1,\n        height: 1,\n        right: left + 1,\n        center: top,\n        middle: left,\n        bottom: top + 1,\n      }\n    } else {\n      anchor = getAnchorPosition(anchorEl, offset)\n    }\n  }\n\n  let target = getTargetPosition(el)\n  let targetPosition = {\n    top: anchor[anchorOrigin.vertical] - target[selfOrigin.vertical],\n    left: anchor[anchorOrigin.horizontal] - target[selfOrigin.horizontal],\n  }\n\n  targetPosition = repositionIfNeeded(anchor, target, selfOrigin, anchorOrigin, targetPosition, cover)\n\n  el.style.top = Math.max(0, targetPosition.top) + 'px'\n  el.style.left = Math.max(0, targetPosition.left) + 'px'\n  if (targetPosition.maxHeight) {\n    el.style.maxHeight = `${targetPosition.maxHeight}px`\n  }\n  if (targetPosition.maxWidth) {\n    el.style.maxWidth = `${targetPosition.maxWidth}px`\n  }\n\n  if (animate) {\n    const directions = targetPosition.top < anchor.top ? ['up', 'down'] : ['down', 'up']\n    el.classList.add(`animate-popup-${directions[0]}`)\n    el.classList.remove(`animate-popup-${directions[1]}`)\n  }\n}\n\nexport function positionValidator (pos) {\n  let parts = pos.split(' ')\n  if (parts.length !== 2) {\n    return false\n  }\n  if (!['top', 'center', 'bottom'].includes(parts[0])) {\n    // eslint-disable-next-line no-console\n    console.error('Anchor/Self position must start with one of top/center/bottom')\n    return false\n  }\n  if (!['left', 'middle', 'right'].includes(parts[1])) {\n    // eslint-disable-next-line no-console\n    console.error('Anchor/Self position must end with one of left/middle/right')\n    return false\n  }\n  return true\n}\n\nexport function offsetValidator (val) {\n  if (!val) {\n    return true\n  }\n  if (val.length !== 2) {\n    return false\n  }\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false\n  }\n  return true\n}\n\nexport function parsePosition (pos) {\n  let parts = pos.split(' ')\n  return { vertical: parts[0], horizontal: parts[1] }\n}\n"]}]}